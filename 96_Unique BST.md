# Leetcode 96 - Unique BST

## Others' Idea 1
The number of unique BST of a sequence whose length is n is the sum of number of unique BST that use 1,2,...,n as the root. Denote the number of unique BST of a sequence as g(n), the number of unique BST that use k as the root as f(n,k). So

```math
g(n)=\sum_{k=1}^{n}f(n,k) 
```

For f(n,k), we can use how many unique BST formed by 1,.., k-1 sequence and how many unique sequence formed by k+1,...,n sequence to compute that. The BST from former sequence will be used as left subtree, BST from the latter sequence will be used as the right subtree. Since the number of unique BST generated by a sorted sequence is only affected by length of the sequence, not the content. Those two number will be g(k-1) and g(n-k). So

```math
f(n,k)=g(k-1)*g(n-k)    1<=k<=n
```

So now we can iteratively compute all g(i), f(i,j). Since g(n) depends on f(n,k) not f(n-i,k), while f(n,k) only depends on g(n-j). So we will initiate g(0) ,then in each iteration we will firstly compute f(n,k) then computer g(n).

```python
class Solution:
    def numTrees(self, n: int) -> int:
        g=[0]*(n+1)
        g[0]=1
        f=[[0]*(n+1) for _ in range(n+1)]
        for i in range(1,n+1):  # i is len of sequence
            for j in range(1,i+1):  # j is the val of root node
                f[i][j]=g[j-1]*g[i-j]
            g[i]=sum(f[i][j] for j in range(1,i+1))
        return g[n]
```

Actually, since f(n,k) only use g(j), j< n. Then g(n)= sum of all f(n,k). So f(n,k) can be eliminated.
```c++
class Solution {
public:
    int numTrees(int n) {
        std::vector<int> g(n+1,0);
        g[0]=1;
        for(int len=1;len<n+1;len++){
            for(int rootVal=1;rootVal<=len;rootVal++){
                g[len]+=g[rootVal-1]*g[len-rootVal];
            }
        }
        return g[n];
    }
};
```

